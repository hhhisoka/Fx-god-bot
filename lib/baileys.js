// lib/baileys.js (modifications)
import makeWASocket, {
    useMultiFileAuthState,
    DisconnectReason,
    fetchLatestBaileysVersion,
    makeInMemoryStore,
    proto
} from "@adiwajshing/baileys";
import { Boom } from "@hapi/boom";
import fs from "fs-extra";
import readline from "readline";
import { v4 as uuidv4 } from 'uuid';
import { createSessionManager } from "./sessionManager.js";
import { handleCommand } from "./commandHandler.js";
import config from "../config.js";

// Global connections store
const connections = {};

// Create readline interface for user input (si pas d'interface web)
let rl;
if (!global.webSocket) {
    rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
}

// Function to ask a question and get user input
const question = text => {
    if (global.webSocket) {
        // Si l'interface web est active, on attend la r√©ponse via socket.io
        return new Promise(resolve => {
            console.log(text);
            global.pendingQuestion = { resolve, text };
        });
    } else {
        // Sinon, on utilise readline
        return new Promise(resolve => rl.question(text, resolve));
    }
};

/**
 * Display session ID information box in console
 * @param {string} sessionId - ID de session √† afficher
 */
const displaySessionInfo = (sessionId) => {
    console.log('\n');
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                    INFORMATION DE SESSION                      ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë Votre ID de session: ${sessionId}`);
    console.log('‚ïë                                                               ‚ïë');
    console.log('‚ïë Pour r√©utiliser cette session √† l\'avenir, ajoutez cette      ‚ïë');
    console.log('‚ïë variable d\'environnement √† votre configuration:              ‚ïë');
    console.log('‚ïë                                                               ‚ïë');
    console.log(`‚ïë SESSION_ID=${sessionId}`);
    console.log('‚ïë                                                               ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    console.log('\n');
};

/**
 * Envoie l'ID de session au propri√©taire via WhatsApp
 * @param {object} sock - Instance de connexion WhatsApp
 * @param {string} sessionId - ID de session √† envoyer
 */
const sendSessionIdToOwner = async (sock, sessionId) => {
    try {
        if (!config.owner) {
            console.log("‚ö†Ô∏è Num√©ro du propri√©taire non d√©fini, impossible d'envoyer l'ID de session");
            return;
        }

        // V√©rifier si nous sommes sur Termux
        if (config.isTermux) {
            console.log("üì± D√©ploiement sur Termux d√©tect√©, l'ID de session n'est pas envoy√© par WhatsApp");
            return;
        }

        const ownerJid = `${config.owner}@s.whatsapp.net`;
        
        // Message avec formatage Markdown pour l'ID de session
        const sessionMessage = `üîê *INFORMATION DE SESSION FX-GOD BOT* üîê\n\n` +
            `üì± *ID de Session*: \`${sessionId}\`\n\n` +
            `Pour r√©utiliser cette session √† l'avenir, ajoutez cette variable d'environnement:\n\n` +
            `\`\`\`\nSESSION_ID=${sessionId}\n\`\`\`\n\n` +
            `‚úÖ *Cette session est active et fonctionnelle*\n` +
            `üìÖ Date: ${new Date().toLocaleString()}\n` +
            `üåê Plateforme: ${getPlatformName()}\n`;
            
        await sock.sendMessage(ownerJid, { text: sessionMessage });
        console.log(`‚úÖ ID de session envoy√© au propri√©taire (${config.owner}) via WhatsApp`);
    } catch (error) {
        console.error("‚ùå Erreur lors de l'envoi de l'ID de session via WhatsApp:", error);
    }
};

/**
 * Obtient le nom de la plateforme de d√©ploiement
 * @returns {string} Nom de la plateforme
 */
const getPlatformName = () => {
    if (config.isHeroku) return "Heroku";
    if (config.isReplit) return "Replit";
    if (config.isGlitch) return "Glitch";
    if (config.isTermux) return "Termux";
    return "Autre";
};

/**
 * Start the WhatsApp bot
 * @param {Object} options Configuration options
 * @returns {Object} WhatsApp connection object
 */
const startBot = async (options = {}) => {
    // G√©n√©rer un ID de session unique s'il n'est pas d√©j√† d√©fini
    if (!config.sessionId || config.sessionId === 'fx-god') {
        config.sessionId = `fx-god-${uuidv4().substring(0, 8)}`;
    }
    
    const sessionManager = createSessionManager(config.sessionId);
    const { state, saveCreds } = await sessionManager.getAuthState();

    // Fetch latest Baileys version
    const { version, isLatest } = await fetchLatestBaileysVersion();
    console.log(`üì± Using WA v${version.join(".")}, isLatest: ${isLatest}`);

    // Create in-memory message store
    const store = makeInMemoryStore({});

    // D√©terminer le mode de connexion (QR ou pairage)
    let usePairingCode = config.usePairingCode;
    let phoneNumber = '';
    
    // Si l'interface web n'est pas active, demander via console
    if (!global.webSocket) {
        usePairingCode = usePairingCode || 
            (await question(`Choisissez une m√©thode de connexion:
1. QR Code (scanner avec votre t√©l√©phone)
2. Pairing Code (entrer un code sur votre t√©l√©phone)
Votre choix (1/2): `)) === "2";

        if (usePairingCode) {
            phoneNumber = await question(
                "Entrez votre num√©ro WhatsApp (format international sans +, ex: 33612345678): "
            );
        }
    } else {
        // Si l'interface web est active, attendre le mode choisi par l'utilisateur
        if (global.webQRRequested) {
            usePairingCode = false;
            global.webQRRequested = false;
        } else if (global.connectionMode === 'pairing') {
            usePairingCode = true;
            phoneNumber = global.pairingPhoneNumber;
        }
    }

    // Set up connection
    const startConnection = async () => {
        const sock = makeWASocket({
            version,
            auth: state,
            printQRInTerminal: !usePairingCode && !global.webSocket,
            browser: ["FX-GOD Bot", "Chrome", "1.0.0"],
            syncFullHistory: false,
            markOnlineOnConnect: !config.ghostMode,
            patchMessageBeforeSending: message => {
                const requiresPatch = !!(
                    message.buttonsMessage ||
                    message.templateMessage ||
                    message.listMessage
                );
                if (requiresPatch) {
                    message = {
                        viewOnceMessage: {
                            message: {
                                messageContextInfo: {
                                    deviceListMetadataVersion: 2,
                                    deviceListMetadata: {}
                                },
                                ...message
                            }
                        }
                    };
                }
                return message;
            }
        });

        connections[config.sessionId] = sock;
        sock.ev.on("creds.update", saveCreds);

        sock.ev.on("connection.update", async update => {
            const { connection, lastDisconnect, qr } = update;

            // G√©rer le QR code
            if (qr) {
                if (global.webSocket) {
                    // Envoyer le QR √† l'interface web
                    global.webSocket.emit('qr', qr);
                    global.webSocket.emit('connectionStatus', 'QR code g√©n√©r√©. En attente de scan...');
                } else if (options.printQR) {
                    options.printQR(qr);
                }
            }

            // G√©rer le code de pairage
            if (usePairingCode && connection === "open" && phoneNumber) {
                try {
                    const code = await sock.requestPairingCode(phoneNumber);
                    
                    if (global.webSocket) {
                        // Envoyer le code de pairage √† l'interface web
                        global.webSocket.emit('pairingCode', code);
                        global.webSocket.emit('connectionStatus', 'Code d\'appairage g√©n√©r√©. En attente d\'entr√©e du code...');
                    } else {
                        console.log(`‚ö° Votre code d'appairage est: ${code}`);
                        console.log(`üì± Sur votre t√©l√©phone: WhatsApp > Appareils li√©s > Lier un appareil > Entrez le code ci-dessus`);
                    }
                } catch (error) {
                    console.error("Erreur lors de la g√©n√©ration du code d'appairage:", error);
                    
                    if (global.webSocket) {
                        global.webSocket.emit('connectionStatus', 'Erreur lors de la g√©n√©ration du code d\'appairage.');
                    }
                }
            }

            // Notification de mise √† jour de connexion
            if (options.onConnectionUpdate) {
                options.onConnectionUpdate(update);
            }

            // Lorsque la connexion est √©tablie
            if (connection === 'open') {
                // Afficher l'ID de session dans la console
                displaySessionInfo(config.sessionId);
                
                // Notifier l'interface web
                if (global.webSocket) {
                    global.webSocket.emit('connected', { 
                        sessionId: config.sessionId,
                        platform: getPlatformName()
                    });
                }
                
                // Attendre un moment pour s'assurer que la connexion est bien √©tablie
                // avant d'envoyer l'ID de session
                setTimeout(async () => {
                    await sendSessionIdToOwner(sock, config.sessionId);
                }, 5000);
                
                // Fermer readline si actif
                if (rl) rl.close();
            }

            // G√©rer la d√©connexion
            if (connection === "close") {
                const shouldReconnect =
                    lastDisconnect?.error instanceof Boom &&
                    lastDisconnect.error.output.statusCode !== DisconnectReason.loggedOut;

                console.log(`üî¥ Connection closed due to ${lastDisconnect?.error}. ${shouldReconnect ? "Reconnecting..." : "Not reconnecting."}`);
                
                if (global.webSocket) {
                    global.webSocket.emit('connectionStatus', `Connexion ferm√©e. ${shouldReconnect ? "Tentative de reconnexion..." : "√âchec de connexion."}`);
                }

                if (shouldReconnect) {
                    await startConnection();
                }
            }
        });

        sock.ev.on("messages.upsert", async ({ messages, type }) => {
            if (type !== "notify") return;
            
            for (const message of messages) {
                try {
                    await handleCommand(sock, message);
                } catch (error) {
                    console.error("Error handling message:", error);
                }
            }
        });

        return sock;
    };

    const conn = await startConnection();
    return { conn, startConnection };
};

/**
 * Get a connection by session ID
 * @param {string} sessionId The session ID 
 * @returns {Object} The WhatsApp connection 
 */
const getConnection = (sessionId) => connections[sessionId || config.sessionId];

export { startBot, getConnection };